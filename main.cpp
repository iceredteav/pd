#include <igl/opengl/glfw/Viewer.h>
#include <igl/AABB.h>
#include <igl/in_element.h>
#include <igl/signed_distance.h>
#include <igl/barycentric_coordinates.h>
#include <igl/unproject_onto_mesh.h>
#include <igl/Timer.h>


#include <iostream>
#include <algorithm>
#include <chrono>
#include <cstddef>
#include <iomanip>
#include <numeric>
#include <vector>
#include<fstream>

volatile int sink;
Eigen::MatrixXd V;
Eigen::MatrixXi F;
typedef Eigen::Triplet<double> T;
typedef Eigen::SparseMatrix<double> SparseMatrixType;
double dt = 0.05;
int maxIte = 10;
int frame = 0;
bool pause = true;

Eigen::Vector3d prePos;
Eigen::Vector3d vel;
//double time;
bool gMouseDown;
igl::Timer timer;

//double mesh_vertices[] = {
//	-1.00,1.00,0.00,0.00,1.00,0.00,1.00,1.00,0.00,
//	-1.00,0.00,0.00,0.00,0.00,0.00,1.00,0.00,0.00,
//	-1.00,-1.00,0.00,0.00,-1.00,0.00,1.00,-1.00,0.00,
//};
//
//int mesh_faceTriIds[] = {
//	0,1,4,0,3,4,1,2,4,2,4,5,
//	3,4,6,4,6,7,4,7,8,4,5,8
//};

//double mesh_vertices[] = {
//	-4.00,4.00,0.00,-3.00,4.00,0.00,-2.00,4.00,0.00,-1.00,4.00,0.00,0.00,4.00,0.00,
//	1.00,4.00,0.00,2.00,4.00,0.00,3.00,4.00,0.00,4.00,4.00,0.00,
//	-4.00,3.00,0.00,-3.00,3.00,0.00,-2.00,3.00,0.00,-1.00,3.00,0.00,0.00,3.00,0.00,
//	1.00,3.00,0.00,2.00,3.00,0.00,3.00,3.00,0.00,4.00,3.00,0.00,
//	-4.00,2.00,0.00,-3.00,2.00,0.00,-2.00,2.00,0.00,-1.00,2.00,0.00,0.00,2.00,0.00,
//	1.00,2.00,0.00,2.00,2.00,0.00,3.00,2.00,0.00,4.00,2.00,0.00,
//	-4.00,1.00,0.00,-3.00,1.00,0.00,-2.00,1.00,0.00,-1.00,1.00,0.00,0.00,1.00,0.00,
//	1.00,1.00,0.00,2.00,1.00,0.00,3.00,1.00,0.00,4.00,1.00,0.00,
//	-4.00,0.00,0.00,-3.00,0.00,0.00,-2.00,0.00,0.00,-1.00,0.00,0.00,0.00,0.00,0.00,
//	1.00,0.00,0.00,2.00,0.00,0.00,3.00,0.00,0.00,4.00,0.00,0.00,
//	-4.00,-1.00,0.00,-3.00,-1.00,0.00,-2.00,-1.00,0.00,-1.00,-1.00,0.00,0.00,-1.00,0.00,
//	1.00,-1.00,0.00,2.00,-1.00,0.00,3.00,-1.00,0.00,4.00,-1.00,0.00,
//	-4.00,-2.00,0.00,-3.00,-2.00,0.00,-2.00,-2.00,0.00,-1.00,-2.00,0.00,0.00,-2.00,0.00,
//	1.00,-2.00,0.00,2.00,-2.00,0.00,3.00,-2.00,0.00,4.00,-2.00,0.00,
//	-4.00,-3.00,0.00,-3.00,-3.00,0.00,-2.00,-3.00,0.00,-1.00,-3.00,0.00,0.00,-3.00,0.00,
//	1.00,-3.00,0.00,2.00,-3.00,0.00,3.00,-3.00,0.00,4.00,-3.00,0.00,
//	-4.00,-4.00,0.00,-3.00,-4.00,0.00,-2.00,-4.00,0.00,-1.00,-4.00,0.00,0.00,-4.00,0.00,
//	1.00,-4.00,0.00,2.00,-4.00,0.00,3.00,-4.00,0.00,4.00,-4.00,0.00
//};
double mesh_vertices[] = {
-2.000000,2.000000,0.000000,-1.800000,2.000000,0.000000,-1.600000,2.000000,0.000000,-1.400000,2.000000,0.000000,-1.200000,2.000000,0.000000,-1.000000,2.000000,0.000000,-0.800000,2.000000,0.000000,-0.600000,2.000000,0.000000,-0.400000,2.000000,0.000000,-0.200000,2.000000,0.000000,0.000000,2.000000,0.000000,0.200000,2.000000,0.000000,0.400000,2.000000,0.000000,0.600000,2.000000,0.000000,0.800000,2.000000,0.000000,1.000000,2.000000,0.000000,1.200000,2.000000,0.000000,1.400000,2.000000,0.000000,1.600000,2.000000,0.000000,1.800000,2.000000,0.000000,2.000000,2.000000,0.000000,
-2.000000,1.800000,0.000000,-1.800000,1.800000,0.000000,-1.600000,1.800000,0.000000,-1.400000,1.800000,0.000000,-1.200000,1.800000,0.000000,-1.000000,1.800000,0.000000,-0.800000,1.800000,0.000000,-0.600000,1.800000,0.000000,-0.400000,1.800000,0.000000,-0.200000,1.800000,0.000000,0.000000,1.800000,0.000000,0.200000,1.800000,0.000000,0.400000,1.800000,0.000000,0.600000,1.800000,0.000000,0.800000,1.800000,0.000000,1.000000,1.800000,0.000000,1.200000,1.800000,0.000000,1.400000,1.800000,0.000000,1.600000,1.800000,0.000000,1.800000,1.800000,0.000000,2.000000,1.800000,0.000000,
-2.000000,1.600000,0.000000,-1.800000,1.600000,0.000000,-1.600000,1.600000,0.000000,-1.400000,1.600000,0.000000,-1.200000,1.600000,0.000000,-1.000000,1.600000,0.000000,-0.800000,1.600000,0.000000,-0.600000,1.600000,0.000000,-0.400000,1.600000,0.000000,-0.200000,1.600000,0.000000,0.000000,1.600000,0.000000,0.200000,1.600000,0.000000,0.400000,1.600000,0.000000,0.600000,1.600000,0.000000,0.800000,1.600000,0.000000,1.000000,1.600000,0.000000,1.200000,1.600000,0.000000,1.400000,1.600000,0.000000,1.600000,1.600000,0.000000,1.800000,1.600000,0.000000,2.000000,1.600000,0.000000,
-2.000000,1.400000,0.000000,-1.800000,1.400000,0.000000,-1.600000,1.400000,0.000000,-1.400000,1.400000,0.000000,-1.200000,1.400000,0.000000,-1.000000,1.400000,0.000000,-0.800000,1.400000,0.000000,-0.600000,1.400000,0.000000,-0.400000,1.400000,0.000000,-0.200000,1.400000,0.000000,0.000000,1.400000,0.000000,0.200000,1.400000,0.000000,0.400000,1.400000,0.000000,0.600000,1.400000,0.000000,0.800000,1.400000,0.000000,1.000000,1.400000,0.000000,1.200000,1.400000,0.000000,1.400000,1.400000,0.000000,1.600000,1.400000,0.000000,1.800000,1.400000,0.000000,2.000000,1.400000,0.000000,
-2.000000,1.200000,0.000000,-1.800000,1.200000,0.000000,-1.600000,1.200000,0.000000,-1.400000,1.200000,0.000000,-1.200000,1.200000,0.000000,-1.000000,1.200000,0.000000,-0.800000,1.200000,0.000000,-0.600000,1.200000,0.000000,-0.400000,1.200000,0.000000,-0.200000,1.200000,0.000000,0.000000,1.200000,0.000000,0.200000,1.200000,0.000000,0.400000,1.200000,0.000000,0.600000,1.200000,0.000000,0.800000,1.200000,0.000000,1.000000,1.200000,0.000000,1.200000,1.200000,0.000000,1.400000,1.200000,0.000000,1.600000,1.200000,0.000000,1.800000,1.200000,0.000000,2.000000,1.200000,0.000000,
-2.000000,1.000000,0.000000,-1.800000,1.000000,0.000000,-1.600000,1.000000,0.000000,-1.400000,1.000000,0.000000,-1.200000,1.000000,0.000000,-1.000000,1.000000,0.000000,-0.800000,1.000000,0.000000,-0.600000,1.000000,0.000000,-0.400000,1.000000,0.000000,-0.200000,1.000000,0.000000,0.000000,1.000000,0.000000,0.200000,1.000000,0.000000,0.400000,1.000000,0.000000,0.600000,1.000000,0.000000,0.800000,1.000000,0.000000,1.000000,1.000000,0.000000,1.200000,1.000000,0.000000,1.400000,1.000000,0.000000,1.600000,1.000000,0.000000,1.800000,1.000000,0.000000,2.000000,1.000000,0.000000,
-2.000000,0.800000,0.000000,-1.800000,0.800000,0.000000,-1.600000,0.800000,0.000000,-1.400000,0.800000,0.000000,-1.200000,0.800000,0.000000,-1.000000,0.800000,0.000000,-0.800000,0.800000,0.000000,-0.600000,0.800000,0.000000,-0.400000,0.800000,0.000000,-0.200000,0.800000,0.000000,0.000000,0.800000,0.000000,0.200000,0.800000,0.000000,0.400000,0.800000,0.000000,0.600000,0.800000,0.000000,0.800000,0.800000,0.000000,1.000000,0.800000,0.000000,1.200000,0.800000,0.000000,1.400000,0.800000,0.000000,1.600000,0.800000,0.000000,1.800000,0.800000,0.000000,2.000000,0.800000,0.000000,
-2.000000,0.600000,0.000000,-1.800000,0.600000,0.000000,-1.600000,0.600000,0.000000,-1.400000,0.600000,0.000000,-1.200000,0.600000,0.000000,-1.000000,0.600000,0.000000,-0.800000,0.600000,0.000000,-0.600000,0.600000,0.000000,-0.400000,0.600000,0.000000,-0.200000,0.600000,0.000000,0.000000,0.600000,0.000000,0.200000,0.600000,0.000000,0.400000,0.600000,0.000000,0.600000,0.600000,0.000000,0.800000,0.600000,0.000000,1.000000,0.600000,0.000000,1.200000,0.600000,0.000000,1.400000,0.600000,0.000000,1.600000,0.600000,0.000000,1.800000,0.600000,0.000000,2.000000,0.600000,0.000000,
-2.000000,0.400000,0.000000,-1.800000,0.400000,0.000000,-1.600000,0.400000,0.000000,-1.400000,0.400000,0.000000,-1.200000,0.400000,0.000000,-1.000000,0.400000,0.000000,-0.800000,0.400000,0.000000,-0.600000,0.400000,0.000000,-0.400000,0.400000,0.000000,-0.200000,0.400000,0.000000,0.000000,0.400000,0.000000,0.200000,0.400000,0.000000,0.400000,0.400000,0.000000,0.600000,0.400000,0.000000,0.800000,0.400000,0.000000,1.000000,0.400000,0.000000,1.200000,0.400000,0.000000,1.400000,0.400000,0.000000,1.600000,0.400000,0.000000,1.800000,0.400000,0.000000,2.000000,0.400000,0.000000,
-2.000000,0.200000,0.000000,-1.800000,0.200000,0.000000,-1.600000,0.200000,0.000000,-1.400000,0.200000,0.000000,-1.200000,0.200000,0.000000,-1.000000,0.200000,0.000000,-0.800000,0.200000,0.000000,-0.600000,0.200000,0.000000,-0.400000,0.200000,0.000000,-0.200000,0.200000,0.000000,0.000000,0.200000,0.000000,0.200000,0.200000,0.000000,0.400000,0.200000,0.000000,0.600000,0.200000,0.000000,0.800000,0.200000,0.000000,1.000000,0.200000,0.000000,1.200000,0.200000,0.000000,1.400000,0.200000,0.000000,1.600000,0.200000,0.000000,1.800000,0.200000,0.000000,2.000000,0.200000,0.000000,
-2.000000,0.000000,0.000000,-1.800000,0.000000,0.000000,-1.600000,0.000000,0.000000,-1.400000,0.000000,0.000000,-1.200000,0.000000,0.000000,-1.000000,0.000000,0.000000,-0.800000,0.000000,0.000000,-0.600000,0.000000,0.000000,-0.400000,0.000000,0.000000,-0.200000,0.000000,0.000000,0.000000,0.000000,0.000000,0.200000,0.000000,0.000000,0.400000,0.000000,0.000000,0.600000,0.000000,0.000000,0.800000,0.000000,0.000000,1.000000,0.000000,0.000000,1.200000,0.000000,0.000000,1.400000,0.000000,0.000000,1.600000,0.000000,0.000000,1.800000,0.000000,0.000000,2.000000,0.000000,0.000000,
-2.000000,-0.200000,0.000000,-1.800000,-0.200000,0.000000,-1.600000,-0.200000,0.000000,-1.400000,-0.200000,0.000000,-1.200000,-0.200000,0.000000,-1.000000,-0.200000,0.000000,-0.800000,-0.200000,0.000000,-0.600000,-0.200000,0.000000,-0.400000,-0.200000,0.000000,-0.200000,-0.200000,0.000000,0.000000,-0.200000,0.000000,0.200000,-0.200000,0.000000,0.400000,-0.200000,0.000000,0.600000,-0.200000,0.000000,0.800000,-0.200000,0.000000,1.000000,-0.200000,0.000000,1.200000,-0.200000,0.000000,1.400000,-0.200000,0.000000,1.600000,-0.200000,0.000000,1.800000,-0.200000,0.000000,2.000000,-0.200000,0.000000,
-2.000000,-0.400000,0.000000,-1.800000,-0.400000,0.000000,-1.600000,-0.400000,0.000000,-1.400000,-0.400000,0.000000,-1.200000,-0.400000,0.000000,-1.000000,-0.400000,0.000000,-0.800000,-0.400000,0.000000,-0.600000,-0.400000,0.000000,-0.400000,-0.400000,0.000000,-0.200000,-0.400000,0.000000,0.000000,-0.400000,0.000000,0.200000,-0.400000,0.000000,0.400000,-0.400000,0.000000,0.600000,-0.400000,0.000000,0.800000,-0.400000,0.000000,1.000000,-0.400000,0.000000,1.200000,-0.400000,0.000000,1.400000,-0.400000,0.000000,1.600000,-0.400000,0.000000,1.800000,-0.400000,0.000000,2.000000,-0.400000,0.000000,
-2.000000,-0.600000,0.000000,-1.800000,-0.600000,0.000000,-1.600000,-0.600000,0.000000,-1.400000,-0.600000,0.000000,-1.200000,-0.600000,0.000000,-1.000000,-0.600000,0.000000,-0.800000,-0.600000,0.000000,-0.600000,-0.600000,0.000000,-0.400000,-0.600000,0.000000,-0.200000,-0.600000,0.000000,0.000000,-0.600000,0.000000,0.200000,-0.600000,0.000000,0.400000,-0.600000,0.000000,0.600000,-0.600000,0.000000,0.800000,-0.600000,0.000000,1.000000,-0.600000,0.000000,1.200000,-0.600000,0.000000,1.400000,-0.600000,0.000000,1.600000,-0.600000,0.000000,1.800000,-0.600000,0.000000,2.000000,-0.600000,0.000000,
-2.000000,-0.800000,0.000000,-1.800000,-0.800000,0.000000,-1.600000,-0.800000,0.000000,-1.400000,-0.800000,0.000000,-1.200000,-0.800000,0.000000,-1.000000,-0.800000,0.000000,-0.800000,-0.800000,0.000000,-0.600000,-0.800000,0.000000,-0.400000,-0.800000,0.000000,-0.200000,-0.800000,0.000000,0.000000,-0.800000,0.000000,0.200000,-0.800000,0.000000,0.400000,-0.800000,0.000000,0.600000,-0.800000,0.000000,0.800000,-0.800000,0.000000,1.000000,-0.800000,0.000000,1.200000,-0.800000,0.000000,1.400000,-0.800000,0.000000,1.600000,-0.800000,0.000000,1.800000,-0.800000,0.000000,2.000000,-0.800000,0.000000,
-2.000000,-1.000000,0.000000,-1.800000,-1.000000,0.000000,-1.600000,-1.000000,0.000000,-1.400000,-1.000000,0.000000,-1.200000,-1.000000,0.000000,-1.000000,-1.000000,0.000000,-0.800000,-1.000000,0.000000,-0.600000,-1.000000,0.000000,-0.400000,-1.000000,0.000000,-0.200000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.200000,-1.000000,0.000000,0.400000,-1.000000,0.000000,0.600000,-1.000000,0.000000,0.800000,-1.000000,0.000000,1.000000,-1.000000,0.000000,1.200000,-1.000000,0.000000,1.400000,-1.000000,0.000000,1.600000,-1.000000,0.000000,1.800000,-1.000000,0.000000,2.000000,-1.000000,0.000000,
-2.000000,-1.200000,0.000000,-1.800000,-1.200000,0.000000,-1.600000,-1.200000,0.000000,-1.400000,-1.200000,0.000000,-1.200000,-1.200000,0.000000,-1.000000,-1.200000,0.000000,-0.800000,-1.200000,0.000000,-0.600000,-1.200000,0.000000,-0.400000,-1.200000,0.000000,-0.200000,-1.200000,0.000000,0.000000,-1.200000,0.000000,0.200000,-1.200000,0.000000,0.400000,-1.200000,0.000000,0.600000,-1.200000,0.000000,0.800000,-1.200000,0.000000,1.000000,-1.200000,0.000000,1.200000,-1.200000,0.000000,1.400000,-1.200000,0.000000,1.600000,-1.200000,0.000000,1.800000,-1.200000,0.000000,2.000000,-1.200000,0.000000,
-2.000000,-1.400000,0.000000,-1.800000,-1.400000,0.000000,-1.600000,-1.400000,0.000000,-1.400000,-1.400000,0.000000,-1.200000,-1.400000,0.000000,-1.000000,-1.400000,0.000000,-0.800000,-1.400000,0.000000,-0.600000,-1.400000,0.000000,-0.400000,-1.400000,0.000000,-0.200000,-1.400000,0.000000,0.000000,-1.400000,0.000000,0.200000,-1.400000,0.000000,0.400000,-1.400000,0.000000,0.600000,-1.400000,0.000000,0.800000,-1.400000,0.000000,1.000000,-1.400000,0.000000,1.200000,-1.400000,0.000000,1.400000,-1.400000,0.000000,1.600000,-1.400000,0.000000,1.800000,-1.400000,0.000000,2.000000,-1.400000,0.000000,
-2.000000,-1.600000,0.000000,-1.800000,-1.600000,0.000000,-1.600000,-1.600000,0.000000,-1.400000,-1.600000,0.000000,-1.200000,-1.600000,0.000000,-1.000000,-1.600000,0.000000,-0.800000,-1.600000,0.000000,-0.600000,-1.600000,0.000000,-0.400000,-1.600000,0.000000,-0.200000,-1.600000,0.000000,0.000000,-1.600000,0.000000,0.200000,-1.600000,0.000000,0.400000,-1.600000,0.000000,0.600000,-1.600000,0.000000,0.800000,-1.600000,0.000000,1.000000,-1.600000,0.000000,1.200000,-1.600000,0.000000,1.400000,-1.600000,0.000000,1.600000,-1.600000,0.000000,1.800000,-1.600000,0.000000,2.000000,-1.600000,0.000000,
-2.000000,-1.800000,0.000000,-1.800000,-1.800000,0.000000,-1.600000,-1.800000,0.000000,-1.400000,-1.800000,0.000000,-1.200000,-1.800000,0.000000,-1.000000,-1.800000,0.000000,-0.800000,-1.800000,0.000000,-0.600000,-1.800000,0.000000,-0.400000,-1.800000,0.000000,-0.200000,-1.800000,0.000000,0.000000,-1.800000,0.000000,0.200000,-1.800000,0.000000,0.400000,-1.800000,0.000000,0.600000,-1.800000,0.000000,0.800000,-1.800000,0.000000,1.000000,-1.800000,0.000000,1.200000,-1.800000,0.000000,1.400000,-1.800000,0.000000,1.600000,-1.800000,0.000000,1.800000,-1.800000,0.000000,2.000000,-1.800000,0.000000,
-2.000000,-2.000000,0.000000,-1.800000,-2.000000,0.000000,-1.600000,-2.000000,0.000000,-1.400000,-2.000000,0.000000,-1.200000,-2.000000,0.000000,-1.000000,-2.000000,0.000000,-0.800000,-2.000000,0.000000,-0.600000,-2.000000,0.000000,-0.400000,-2.000000,0.000000,-0.200000,-2.000000,0.000000,0.000000,-2.000000,0.000000,0.200000,-2.000000,0.000000,0.400000,-2.000000,0.000000,0.600000,-2.000000,0.000000,0.800000,-2.000000,0.000000,1.000000,-2.000000,0.000000,1.200000,-2.000000,0.000000,1.400000,-2.000000,0.000000,1.600000,-2.000000,0.000000,1.800000,-2.000000,0.000000,2.000000,-2.000000,0.000000
};
//int mesh_faceTriIds[] = {
//	/*0,1,10,0,10,9,1,2,11,1,11,10,2,3,11,3,12,11,3,4,12,4,13,12,4,5,14,4,14,13,5,6,14,6,15,14,6,7,15,7,16,15,7,8,16,8,17,16,
//	9,10,18,10,19,18,10,11,19,11,20,19,11,12,21,11,21,20,12,13,22,12,22,21,13,14,23,13,23,22,14,15,24,14,24,23,15,16,25,15,25,24,16,17,26,16,26,25,
//	18,19,28,18,28,27,19,20,28,20,29,28,20,21,30,20,30,29,21,22,30,22,31,30,22,23,32,22,32,31,23,24,32,24,33,32,24,25,33,25,34,33,25,26,35,25,35,34,
//	27,28,36,28,37,36,28,29,37,29,38,37,29,30,39,29,39,38,30,31,39,31,40,39,31,32,40,32,41,40,32,33,42,32,42,41,33,34,43,33,43,42,34,35,43,35,44,43,
//	36,37,46,36,46,45,37,38,46,38,47,46,38,39,48,38,48,47,39,40,48,40,49,48,40,41,50,40,50,49,41,42,51,41,51,50,42,43,52,42,52,51,43,44,52,44,53,52,
//	45,46,55,45,55,54,46,47,56,46,56,55,47,48,56,48,57,56,48,49,58,48,58,57,49,50,59,49,59,58,50,51,59,51,60,59,51,52,61,51,61,60,52,53,62,52,62,61,
//	54,55,64,54,64,63,55,56,64,56,65,64,56,57,66,56,66,65,57,58,66,58,67,66,58,59,67,59,68,67,59,60,69,59,69,68,60,61,70,60,70,69,61,62,71,61,71,70,
//	63,64,73,63,73,72,64,65,74,64,74,73,65,66,75,65,75,74,66,67,75,67,76,75,67,68,76,68,77,76,68,69,78,68,78,77,69,70,78,70,79,78,70,71,79,71,80,79*/
//};
int mesh_faceTriIds[] = {
0,21,22,0,22,1,1,22,2,22,23,2,2,23,24,2,24,3,3,24,4,24,25,4,4,25,26,4,26,5,5,26,6,26,27,6,6,27,28,6,28,7,7,28,8,28,29,8,8,29,30,8,30,9,9,30,10,30,31,10,10,31,32,10,32,11,11,32,12,32,33,12,12,33,34,12,34,13,13,34,14,34,35,14,14,35,36,14,36,15,15,36,16,36,37,16,16,37,38,16,38,17,17,38,18,38,39,18,18,39,40,18,40,19,19,40,20,40,41,20,
21,42,22,42,43,22,22,43,44,22,44,23,23,44,24,44,45,24,24,45,46,24,46,25,25,46,26,46,47,26,26,47,48,26,48,27,27,48,28,48,49,28,28,49,50,28,50,29,29,50,30,50,51,30,30,51,52,30,52,31,31,52,32,52,53,32,32,53,54,32,54,33,33,54,34,54,55,34,34,55,56,34,56,35,35,56,36,56,57,36,36,57,58,36,58,37,37,58,38,58,59,38,38,59,60,38,60,39,39,60,40,60,61,40,40,61,62,40,62,41,
42,63,64,42,64,43,43,64,44,64,65,44,44,65,66,44,66,45,45,66,46,66,67,46,46,67,68,46,68,47,47,68,48,68,69,48,48,69,70,48,70,49,49,70,50,70,71,50,50,71,72,50,72,51,51,72,52,72,73,52,52,73,74,52,74,53,53,74,54,74,75,54,54,75,76,54,76,55,55,76,56,76,77,56,56,77,78,56,78,57,57,78,58,78,79,58,58,79,80,58,80,59,59,80,60,80,81,60,60,81,82,60,82,61,61,82,62,82,83,62,
63,84,64,84,85,64,64,85,86,64,86,65,65,86,66,86,87,66,66,87,88,66,88,67,67,88,68,88,89,68,68,89,90,68,90,69,69,90,70,90,91,70,70,91,92,70,92,71,71,92,72,92,93,72,72,93,94,72,94,73,73,94,74,94,95,74,74,95,96,74,96,75,75,96,76,96,97,76,76,97,98,76,98,77,77,98,78,98,99,78,78,99,100,78,100,79,79,100,80,100,101,80,80,101,102,80,102,81,81,102,82,102,103,82,82,103,104,82,104,83,
84,105,106,84,106,85,85,106,86,106,107,86,86,107,108,86,108,87,87,108,88,108,109,88,88,109,110,88,110,89,89,110,90,110,111,90,90,111,112,90,112,91,91,112,92,112,113,92,92,113,114,92,114,93,93,114,94,114,115,94,94,115,116,94,116,95,95,116,96,116,117,96,96,117,118,96,118,97,97,118,98,118,119,98,98,119,120,98,120,99,99,120,100,120,121,100,100,121,122,100,122,101,101,122,102,122,123,102,102,123,124,102,124,103,103,124,104,124,125,104,
105,126,106,126,127,106,106,127,128,106,128,107,107,128,108,128,129,108,108,129,130,108,130,109,109,130,110,130,131,110,110,131,132,110,132,111,111,132,112,132,133,112,112,133,134,112,134,113,113,134,114,134,135,114,114,135,136,114,136,115,115,136,116,136,137,116,116,137,138,116,138,117,117,138,118,138,139,118,118,139,140,118,140,119,119,140,120,140,141,120,120,141,142,120,142,121,121,142,122,142,143,122,122,143,144,122,144,123,123,144,124,144,145,124,124,145,146,124,146,125,
126,147,148,126,148,127,127,148,128,148,149,128,128,149,150,128,150,129,129,150,130,150,151,130,130,151,152,130,152,131,131,152,132,152,153,132,132,153,154,132,154,133,133,154,134,154,155,134,134,155,156,134,156,135,135,156,136,156,157,136,136,157,158,136,158,137,137,158,138,158,159,138,138,159,160,138,160,139,139,160,140,160,161,140,140,161,162,140,162,141,141,162,142,162,163,142,142,163,164,142,164,143,143,164,144,164,165,144,144,165,166,144,166,145,145,166,146,166,167,146,
147,168,148,168,169,148,148,169,170,148,170,149,149,170,150,170,171,150,150,171,172,150,172,151,151,172,152,172,173,152,152,173,174,152,174,153,153,174,154,174,175,154,154,175,176,154,176,155,155,176,156,176,177,156,156,177,178,156,178,157,157,178,158,178,179,158,158,179,180,158,180,159,159,180,160,180,181,160,160,181,182,160,182,161,161,182,162,182,183,162,162,183,184,162,184,163,163,184,164,184,185,164,164,185,186,164,186,165,165,186,166,186,187,166,166,187,188,166,188,167,
168,189,190,168,190,169,169,190,170,190,191,170,170,191,192,170,192,171,171,192,172,192,193,172,172,193,194,172,194,173,173,194,174,194,195,174,174,195,196,174,196,175,175,196,176,196,197,176,176,197,198,176,198,177,177,198,178,198,199,178,178,199,200,178,200,179,179,200,180,200,201,180,180,201,202,180,202,181,181,202,182,202,203,182,182,203,204,182,204,183,183,204,184,204,205,184,184,205,206,184,206,185,185,206,186,206,207,186,186,207,208,186,208,187,187,208,188,208,209,188,
189,210,190,210,211,190,190,211,212,190,212,191,191,212,192,212,213,192,192,213,214,192,214,193,193,214,194,214,215,194,194,215,216,194,216,195,195,216,196,216,217,196,196,217,218,196,218,197,197,218,198,218,219,198,198,219,220,198,220,199,199,220,200,220,221,200,200,221,222,200,222,201,201,222,202,222,223,202,202,223,224,202,224,203,203,224,204,224,225,204,204,225,226,204,226,205,205,226,206,226,227,206,206,227,228,206,228,207,207,228,208,228,229,208,208,229,230,208,230,209,
210,231,232,210,232,211,211,232,212,232,233,212,212,233,234,212,234,213,213,234,214,234,235,214,214,235,236,214,236,215,215,236,216,236,237,216,216,237,238,216,238,217,217,238,218,238,239,218,218,239,240,218,240,219,219,240,220,240,241,220,220,241,242,220,242,221,221,242,222,242,243,222,222,243,244,222,244,223,223,244,224,244,245,224,224,245,246,224,246,225,225,246,226,246,247,226,226,247,248,226,248,227,227,248,228,248,249,228,228,249,250,228,250,229,229,250,230,250,251,230,
231,252,232,252,253,232,232,253,254,232,254,233,233,254,234,254,255,234,234,255,256,234,256,235,235,256,236,256,257,236,236,257,258,236,258,237,237,258,238,258,259,238,238,259,260,238,260,239,239,260,240,260,261,240,240,261,262,240,262,241,241,262,242,262,263,242,242,263,264,242,264,243,243,264,244,264,265,244,244,265,266,244,266,245,245,266,246,266,267,246,246,267,268,246,268,247,247,268,248,268,269,248,248,269,270,248,270,249,249,270,250,270,271,250,250,271,272,250,272,251,
252,273,274,252,274,253,253,274,254,274,275,254,254,275,276,254,276,255,255,276,256,276,277,256,256,277,278,256,278,257,257,278,258,278,279,258,258,279,280,258,280,259,259,280,260,280,281,260,260,281,282,260,282,261,261,282,262,282,283,262,262,283,284,262,284,263,263,284,264,284,285,264,264,285,286,264,286,265,265,286,266,286,287,266,266,287,288,266,288,267,267,288,268,288,289,268,268,289,290,268,290,269,269,290,270,290,291,270,270,291,292,270,292,271,271,292,272,292,293,272,
273,294,274,294,295,274,274,295,296,274,296,275,275,296,276,296,297,276,276,297,298,276,298,277,277,298,278,298,299,278,278,299,300,278,300,279,279,300,280,300,301,280,280,301,302,280,302,281,281,302,282,302,303,282,282,303,304,282,304,283,283,304,284,304,305,284,284,305,306,284,306,285,285,306,286,306,307,286,286,307,308,286,308,287,287,308,288,308,309,288,288,309,310,288,310,289,289,310,290,310,311,290,290,311,312,290,312,291,291,312,292,312,313,292,292,313,314,292,314,293,
294,315,316,294,316,295,295,316,296,316,317,296,296,317,318,296,318,297,297,318,298,318,319,298,298,319,320,298,320,299,299,320,300,320,321,300,300,321,322,300,322,301,301,322,302,322,323,302,302,323,324,302,324,303,303,324,304,324,325,304,304,325,326,304,326,305,305,326,306,326,327,306,306,327,328,306,328,307,307,328,308,328,329,308,308,329,330,308,330,309,309,330,310,330,331,310,310,331,332,310,332,311,311,332,312,332,333,312,312,333,334,312,334,313,313,334,314,334,335,314,
315,336,316,336,337,316,316,337,338,316,338,317,317,338,318,338,339,318,318,339,340,318,340,319,319,340,320,340,341,320,320,341,342,320,342,321,321,342,322,342,343,322,322,343,344,322,344,323,323,344,324,344,345,324,324,345,346,324,346,325,325,346,326,346,347,326,326,347,348,326,348,327,327,348,328,348,349,328,328,349,350,328,350,329,329,350,330,350,351,330,330,351,352,330,352,331,331,352,332,352,353,332,332,353,354,332,354,333,333,354,334,354,355,334,334,355,356,334,356,335,
336,357,358,336,358,337,337,358,338,358,359,338,338,359,360,338,360,339,339,360,340,360,361,340,340,361,362,340,362,341,341,362,342,362,363,342,342,363,364,342,364,343,343,364,344,364,365,344,344,365,366,344,366,345,345,366,346,366,367,346,346,367,368,346,368,347,347,368,348,368,369,348,348,369,370,348,370,349,349,370,350,370,371,350,350,371,372,350,372,351,351,372,352,372,373,352,352,373,374,352,374,353,353,374,354,374,375,354,354,375,376,354,376,355,355,376,356,376,377,356,
357,378,358,378,379,358,358,379,380,358,380,359,359,380,360,380,381,360,360,381,382,360,382,361,361,382,362,382,383,362,362,383,384,362,384,363,363,384,364,384,385,364,364,385,386,364,386,365,365,386,366,386,387,366,366,387,388,366,388,367,367,388,368,388,389,368,368,389,390,368,390,369,369,390,370,390,391,370,370,391,392,370,392,371,371,392,372,392,393,372,372,393,394,372,394,373,373,394,374,394,395,374,374,395,396,374,396,375,375,396,376,396,397,376,376,397,398,376,398,377,
378,399,400,378,400,379,379,400,380,400,401,380,380,401,402,380,402,381,381,402,382,402,403,382,382,403,404,382,404,383,383,404,384,404,405,384,384,405,406,384,406,385,385,406,386,406,407,386,386,407,408,386,408,387,387,408,388,408,409,388,388,409,410,388,410,389,389,410,390,410,411,390,390,411,412,390,412,391,391,412,392,412,413,392,392,413,414,392,414,393,393,414,394,414,415,394,394,415,416,394,416,395,395,416,396,416,417,396,396,417,418,396,418,397,397,418,398,418,419,398,
399,420,400,420,421,400,400,421,422,400,422,401,401,422,402,422,423,402,402,423,424,402,424,403,403,424,404,424,425,404,404,425,426,404,426,405,405,426,406,426,427,406,406,427,428,406,428,407,407,428,408,428,429,408,408,429,430,408,430,409,409,430,410,430,431,410,410,431,432,410,432,411,411,432,412,432,433,412,412,433,434,412,434,413,413,434,414,434,435,414,414,435,436,414,436,415,415,436,416,436,437,416,416,437,438,416,438,417,417,438,418,438,439,418,418,439,440,418,440,419
};


int attachmentIds[] = {
	0,20
};


void init_mesh() {
	int num_vertices = sizeof(mesh_vertices) / sizeof(mesh_vertices[0]) / 3;
	int num_tris = sizeof(mesh_faceTriIds) / sizeof(mesh_faceTriIds[0]) / 3;
	V.resize(num_vertices, 3);
	F.resize(num_tris, 3);
	for (int i = 0; i < num_vertices;i++) {
		for (int j = 0;j < 3;j++) {
			V(i, j) = mesh_vertices[3 * i + j ];
		}
	}

	for (int i = 0; i < num_tris;i++) {
		for (int j = 0; j < 3;j++) {
			F(i, j) = mesh_faceTriIds[3 * i + j];
		}
	}
}

class Cloth {
	private:
		void sort_vec(const Eigen::MatrixXi& mtrx, Eigen::MatrixXi& sorted_mtrx, Eigen::VectorXi& ind) {
			ind = Eigen::VectorXi::LinSpaced(mtrx.rows(), 0, mtrx.rows() - 1);
			auto rule = [mtrx](int i, int j)->bool
			{
				return mtrx(i, 2) < mtrx(j, 2);
			};
			std::sort(ind.data(), ind.data() + ind.size(), rule);
			//data成员函数返回VectorXd的第一个元素的指针，类似于begin()
			sorted_mtrx.resize(mtrx.rows(), mtrx.cols());
			for (int i = 0;i < mtrx.rows();i++) {
				sorted_mtrx.row(i) = mtrx.row(ind(i));
			}
		}
		struct Edge {
			int id0;
			int id1;
			int edgeNr;
		};

		Eigen::MatrixXi getEdges(int triIds[],int numTris) {
			// create common edges
			std::vector<Edge> edges;
			Eigen::MatrixXi sorted_edges;
			//int numTris = sizeof(triIds) / sizeof(triIds[0]) / 3;

			for (int i = 0; i < numTris; i++) {
				for (int j = 0; j < 3; j++) {
					int id0 = triIds[3 * i + j];
					int id1 = triIds[3 * i + (j + 1) % 3];
					edges.push_back({ std::min(id0, id1), std::max(id0, id1), 3 * i + j });
				}
			}
			//get sorted edges
			// sort so common edges are next to each other
			std::sort(edges.begin(), edges.end(),
				[](const Edge& a, const Edge& b) {
					return (a.id0 < b.id0) || (a.id0 == b.id0 && a.id1 <  b.id1);
				});

			// find matching edges
			std::vector<int> neighbors(3 * numTris, -1);

			int nr = 0;
			while (nr < edges.size()) {
				Edge e0 = edges[nr];
				nr++;
				if (nr < edges.size()) {
					Edge e1 = edges[nr];
					if (e0.id0 == e1.id0 && e0.id1 == e1.id1) {
						neighbors[e0.edgeNr] = e1.edgeNr;
						//neighbors[e1.edgeNr] = e0.edgeNr;
					}
				}
			}
			//delete repeated edges
			int k = 0;
			sorted_edges.resize(edges.size(),2);
			for (int i = 0;i < edges.size();i++) {
				int id0 = edges[i].id0;
				int id1 = edges[i].id1;
				int n = neighbors[edges[i].edgeNr];
				if (n < 0) {
					sorted_edges(k, 0) = id0;
					sorted_edges(k, 1) = id1;
					k++;
				}
			}
			num_edges = k;

			return sorted_edges;
		}

		void RemoveRow(Eigen::MatrixXd& matrix, unsigned int rowToRemove) {
			unsigned int numRows = matrix.rows() - 1;
			unsigned int numCols = matrix.cols();

			if (rowToRemove < numRows) {
				matrix.block(rowToRemove, 0, numRows - rowToRemove, numCols) =
					matrix.block(rowToRemove + 1, 0, numRows - rowToRemove, numCols);
			}

			matrix.conservativeResize(numRows, numCols);
		}

		void RemoveColumn(Eigen::MatrixXd& matrix, unsigned int colToRemove) {
			unsigned int numRows = matrix.rows();
			unsigned int numCols = matrix.cols() - 1;

			if (colToRemove < numCols) {
				matrix.block(0, colToRemove, numRows, numCols - colToRemove) =
					matrix.block(0, colToRemove + 1, numRows, numCols - colToRemove);
			}

			matrix.conservativeResize(numRows, numCols);
		}

	public:
		Eigen::MatrixXd pos_; //position N*3
		Eigen::MatrixXd old_pos_;//N*3
		Eigen::MatrixXd vel_; //velocity N*3
		Eigen::MatrixXd w_;//M N*N 
		Eigen::MatrixXd M;//3N * 3N
		Eigen::MatrixXd M_dt;//3N*3N
		Eigen::MatrixXd inv_w_;//M-1 N*N
		Eigen::MatrixXd gravity;//N*3
		Eigen::MatrixXi faces_;
		Eigen::MatrixXi edges_;//M*2
		Eigen::VectorXd rest_length_;//M*1
		Eigen::MatrixXd lambda;
		Eigen::SimplicialCholesky<SparseMatrixType> cholesky_decomposition_;
		Eigen::VectorXd map;//N*1

		int num_vertices;//N
		int num_edges;//M
		int num_att;
		int num_tris;
		double wi;//stiffness?
		int grabId = -1;
		double grab_inv_mas;
		const double compliance = 0.006;
		const double k = 1 / compliance;
		bool flag = false;
		int cnt = 0;
		double a;
		double lastF;

		Cloth(double dt) {
			init_mesh();
			//std::cout << V.rows() << std::endl;
			//std::cout << F.rows() << std::endl;
			//init pos_ faces_
			pos_ = V;
			faces_ = F;
			num_vertices = pos_.rows();
			num_tris = faces_.rows();
			num_att = sizeof(attachmentIds) / sizeof(attachmentIds[0]);
			/*std::cout << pos_;*/
			//get edges_,rest_length_ for 
			edges_ = getEdges(mesh_faceTriIds, num_tris);
			//std::cout << edges_ << std::endl;
			
			init_physical_data(dt);

		}
		void init_physical_data(double dt) {
			old_pos_ = pos_;
			vel_ = Eigen::MatrixXd::Zero(num_vertices, 3);
			w_ = Eigen::MatrixXd::Zero(num_vertices, num_vertices);
			inv_w_= Eigen::MatrixXd::Zero(num_vertices, num_vertices);
			lambda = Eigen::MatrixXd::Zero(num_edges, 1);
			M = Eigen::MatrixXd::Zero(3 * num_vertices, 3 * num_vertices);
			M_dt = Eigen::MatrixXd::Zero(3 * num_vertices, 3 * num_vertices);
			map = Eigen::VectorXd::Zero(3 * num_vertices, 1);
			double mass = 1;
			double temp = mass / dt / dt;
			int attachCnt = 0;
			for (int i = 0;i < num_vertices;i++) {
				if (std::find(attachmentIds, attachmentIds + num_att, i) == attachmentIds + num_att) {
					//not attachment
					map(i) = i - attachCnt;
				}
				else {
					map(i) = -1;
					attachCnt++;
				}
				M(3 * i, 3 * i) = mass;
				M(3 * i+1, 3 * i+1) = mass;
				M(3 * i+2, 3 * i+2) = mass;
				M_dt(3 * i, 3 * i) = temp;
				M_dt(3 * i + 1, 3 * i + 1) = temp;
				M_dt(3 * i + 2, 3 * i + 2) = temp;
				w_(i, i) = 1;
				inv_w_(i, i) = 1;
			}
			
			wi = 0.5;
			gravity = Eigen::MatrixXd::Zero(num_vertices, 3);
			for (int i = 0;i < num_vertices;i++) {
				gravity(i, 1) = -9.8;
			}
		}


		void init_constraints() {
			rest_length_.resize(num_edges);
			for (int i = 0;i < num_edges;i++) {
				int id0 = edges_(i, 0);
				int id1 = edges_(i, 1);
				Eigen::Vector3d const p1 = pos_.row(id0);
				Eigen::Vector3d const p2 = pos_.row(id1);
				rest_length_(i) = (p1 - p2).norm();
			}
		}



		void PBD_presolve(double dt) {
			old_pos_ = pos_;
			for (int i = 0;i < num_vertices;i++) {
				if (std::find(attachmentIds, attachmentIds + num_att, i) == attachmentIds + num_att) {
					//not attachment update
					vel_.row(i) += gravity.row(i) * dt;
					pos_.row(i) += vel_.row(i) * dt;
				}
			}
			/*for (int i = 0;i < num_vertices;i++) {
				if (inv_w_(i, i) != 0) {
					vel_.row(i) += gravity.row(i) * dt;
					pos_.row(i) += vel_.row(i) * dt;
				}
			}*/
			lambda = Eigen::MatrixXd::Zero(num_edges, 1);
			cnt = 0;
			a = 1;
			lastF = 0;
			for (int i = 0;i <num_edges;i++) {
				int id0 = edges_(i, 0);
				int id1 = edges_(i, 1);
				Eigen::Vector3d const p0 = pos_.row(id0);
				Eigen::Vector3d const p1 = pos_.row(id1);
				//C(i) = (p0 - p1).norm() - L(i);
				Eigen::Vector3d x = p0 - p1;
				double n_L = (p0 - p1).norm();
				lastF += 0.5 * k * (n_L - rest_length_(i)) * (n_L - rest_length_(i));
			}

		}

		void PBD_solve() {
			PBD_stretchingsolve();
		}

		void PBD_stretchingsolve() {
			for (int i = 0;i < num_edges;i++) {
				int id1 = edges_(i, 0);
				int id2 = edges_(i, 1);
				Eigen::Vector3d  q1 = pos_.row(id1);
				Eigen::Vector3d  q2 = pos_.row(id2);
				double res_length = rest_length_(i);
				double length = (q1 - q2).norm();
				//if (id1 == 0 && id2 == 1) {
				//	std::cout << "point12_length:" << std::endl;
				//	std::cout << length << std::endl;
				//	std::cout << q1 << std::endl;
				//	std::cout << q2 << std::endl;
				//}
				Eigen::Vector3d  n = (q1 - q2) / length;
				double lambda1 = inv_w_(id1, id1) / (inv_w_(id1, id1) + inv_w_(id2, id2));
				double lambda2 = inv_w_(id2, id2) / (inv_w_(id1, id1) + inv_w_(id2, id2));
				pos_.row(id1) -= lambda1 * (length - res_length) * n;//mass相等
				pos_.row(id2) += lambda2 * (length - res_length) * n;
			}
		}

		void PBD_postsolve(double dt) {
			vel_ = (pos_ - old_pos_) / dt;
		}

		void XPBDSolve(double dt) {
			//get C(NC,1) & J(NC,3*N)
			int N = num_vertices;
			int NC = num_edges;
			const double alpha = 0.000005 / dt / dt;
			//const double alpha = 0;
			Eigen::VectorXd C = Eigen::VectorXd::Zero(NC);
			Eigen::MatrixXd J = Eigen::MatrixXd::Zero(NC, 3 * N);//gradient C
			for (int i = 0;i < num_edges;i++) {
				int id0 = edges_(i, 0);
				int id1 = edges_(i, 1);
				Eigen::Vector3d const p0 = pos_.row(id0);
				Eigen::Vector3d const p1 = pos_.row(id1);
				C(i) = (p0 - p1).norm() - rest_length_(i);
				Eigen::Vector3d n = (p0 - p1) / (p0 - p1).norm();
				J.block<1, 3>(i, 3 * id0) = n;
				J.block<1, 3>(i, 3 * id1) = -n;
			}
			//get A 
			Eigen::MatrixXd A = Eigen::MatrixXd::Zero(3 * N + NC, 3 * N + NC);
			//A.block<3 * N, 3 * N>(0, 0) = M;
			for (int i = 0;i <  N;i++) {
				A(3 * i, 3 * i) = M(3 * i, 3 * i);
				A(3 * i + 1, 3 * i + 1) = M(3 * i + 1, 3 * i + 1);
				A(3 * i + 2, 3 * i + 2) = M(3 * i + 2, 3 * i + 2);
			}
			//A.block<NC, 3 * N>(3 * N, 0) = J;
			for (int i = 0;i < NC;i++) {
				for (int j = 0;j < 3 * N;j++) {
					A(3 * N + i, j) = J(i, j);
				}
			}
			//A.block<3 * N, NC>(0, 3 * N) = -J.transpose();
			for (int i = 0;i < 3*N;i++) {
				for (int j = 0;j < NC;j++) {
					A(i, 3 * N + j) = -J.transpose()(i, j);
				}
			}
			//A.block<NC, NC>(3 * N, 3 * N) = alpha * Eigen::MatrixXd::Identity(NC, NC);
			for (int i = 0;i < NC;i++) {
				for (int j = 0;j < NC;j++) {
					A(3 * N + i, 3 * N + j) = alpha;
				}
			}
			/*std::cout << "A" << std::endl;
			std::cout << A << std::endl;*/
			//get b
			Eigen::MatrixXd b = Eigen::MatrixXd::Zero(3 * N + NC, 1);
			//b.block<NC, 1>(3 * N, 0) = -(C + alpha * lambda);
			for (int i = 0;i < NC;i++) {
				b(3*N+i, 0) = -(C(i, 0) + alpha * lambda(i, 0));
			}
			/*std::cout << "b" << std::endl;
			std::cout << b << std::endl;*/
			//solve Ax=b
			Eigen::MatrixXd x(3 * N + NC, 1);
			x = A.ldlt().solve(b);
			std::cout << "x" << std::endl;
			std::cout << x << std::endl;
			//update V & lambda
			for (int i = 0;i < N;i++) {
				if (w_(i, i) < 1e6) {
					pos_(i, 0) += x(3 * i, 0);
					pos_(i, 1) += x(3 * i + 1, 0);
					pos_(i, 2) += x(3 * i + 2, 0);
				}
			}
			std::cout << "pos_" << std::endl;
			std::cout << pos_ << std::endl;
			for (int i = 0;i < NC;i++) {
				lambda(i, 0) += x(3 * N + i, 0);
			}
		}

		void NewtonSolve(double dt) {
			//A= M/h^2+H
			//b= -M/h^2(..)+f
			//get H (3N*3N)
			int N = num_vertices;
			int NC = num_edges;
			//Eigen::MatrixXd H = Eigen::MatrixXd::Zero(3 * N, 3 * N);
			Eigen::MatrixXd F = Eigen::MatrixXd::Zero(3 * N, 1);
			std::vector<T> tripletList_A;
			for (int i = 0;i < N;i++) {
				if (map(i) != -1) {
					tripletList_A.push_back(T(3 * map(i), 3 * map(i), M_dt(3 * i, 3 * i)));
					tripletList_A.push_back(T(3 * map(i) + 1, 3 * map(i) + 1, M_dt(3 * i, 3 * i)));
					tripletList_A.push_back(T(3 * map(i) + 2, 3 * map(i) + 2, M_dt(3 * i, 3 * i)));
				}
			}
			for (int i = 0;i < NC;i++) {
				int id0 = edges_(i, 0);
				int id1 = edges_(i, 1);
				Eigen::Vector3d const p0 = pos_.row(id0);
				Eigen::Vector3d const p1 = pos_.row(id1);
				//C(i) = (p0 - p1).norm() - L(i);
				Eigen::Vector3d x = p0 - p1;
				double n_L = (p0 - p1).norm();
				Eigen::Vector3d f = -k * (n_L - rest_length_(i)) * (x / n_L);
				F.block<3, 1>(3 * id0, 0) += f;
				F.block<3, 1>(3 * id1, 0) -= f;
				Eigen::MatrixXd He = Eigen::MatrixXd::Zero(3, 3);
				He = k * (x * x.transpose()) / (n_L * n_L) + k * (1 - rest_length_(i) / n_L) * (Eigen::MatrixXd::Identity(3, 3) - x * x.transpose() / (n_L * n_L));
				for (int j = 0;j < 3;j++) {
					for (int k = 0;k < 3;k++) {
						if (map(id0) != -1) {
							tripletList_A.push_back(T(3 * map(id0)+j, 3 * map(id0)+k, He(j,k)));
							if (map(id1) != -1) {
								tripletList_A.push_back(T(3 * map(id0) + j, 3 * map(id1) + k, -He(j, k)));
							}
						}
						if (map(id1) != -1) {
							tripletList_A.push_back(T(3 * map(id1) + j, 3 * map(id1) + k, He(j, k)));
							if (map(id0) != -1) {
								tripletList_A.push_back(T(3 * map(id1) + j, 3 * map(id0) + k, -He(j, k)));
							}
						}
						
					}
				}
				/*H.block<3, 3>(3 * id0, 3 * id0) += He;
				H.block<3, 3>(3 * id1, 3 * id1) += He;
				H.block<3, 3>(3 * id0, 3 * id1) -= He;
				H.block<3, 3>(3 * id1, 3 * id0) -= He;*/

			}
			SparseMatrixType A(3*(N-num_att), 3*(N-num_att));
			A.setFromTriplets(tripletList_A.begin(), tripletList_A.end());
			cholesky_decomposition_.compute(A);
			//get b
			Eigen::MatrixXd b = Eigen::MatrixXd::Zero(3 * N, 1);
			Eigen::MatrixXd line_x = Eigen::MatrixXd::Zero(3 * N, 1);
			for (int i = 0;i < N;i++) {
				line_x(3 * i, 0) = pos_(i, 0) - old_pos_(i, 0) - dt * vel_(i, 0);
				line_x(3 * i + 1, 0) = pos_(i, 1) - old_pos_(i, 1) - dt * vel_(i, 1);
				line_x(3 * i + 2, 0) = pos_(i, 2) - old_pos_(i, 2) - dt * vel_(i, 2);
			}
			b = -M * line_x / (dt * dt) + F;
			for (int i = 0;i < num_att;i++) {
				RemoveRow(b, 3 * attachmentIds[i] - 3 * i);
				RemoveRow(b, 3 * attachmentIds[i] - 3 * i);
				RemoveRow(b, 3 * attachmentIds[i] - 3 * i);
			}
			/*std::cout << "b" << std::endl;
			std::cout << b << std::endl;*/
			Eigen::MatrixXd deta_x(3 * (N-num_att), 1);
			//deta_x = A.ldlt().solve(b);
			deta_x = cholesky_decomposition_.solve(b.col(0));
			cnt++;
			if (deta_x.norm() < 1e-5) {
				flag = true;
			}
			int cnt_ = 0;
			for (int i = 0;i < N;i++) {
				if (std::find(attachmentIds, attachmentIds + num_att, i) == attachmentIds + num_att) {
					//not attachment update position
					pos_(i , 0) += deta_x(3 * (i-cnt_), 0);
					pos_(i , 1) += deta_x(3 * (i - cnt_)+1, 0);
					pos_(i , 2) += deta_x(3 * (i - cnt_)+2, 0);
				}
				else {
					cnt_++;
				}
			}

		}

		void GradientDescentSolve(double h) {
			int N = num_vertices;
			int NC = num_edges;
			Eigen::MatrixXd F = Eigen::MatrixXd::Zero(3 * N, 1);
			for (int i = 0;i < NC;i++) {
				int id0 = edges_(i, 0);
				int id1 = edges_(i, 1);
				Eigen::Vector3d const p0 = pos_.row(id0);
				Eigen::Vector3d const p1 = pos_.row(id1);
				//C(i) = (p0 - p1).norm() - L(i);
				Eigen::Vector3d x = p0 - p1;
				double n_L = (p0 - p1).norm();
				Eigen::Vector3d f = -k * (n_L - rest_length_(i)) * (x / n_L);
				F.block<3, 1>(3 * id0, 0) += f;
				F.block<3, 1>(3 * id1, 0) -= f;
			}
			std::cout << "F(1)" << std::endl;
			std::cout << F(3, 0) << std::endl;
			std::cout << F(4, 0) << std::endl;
			std::cout << F(5,0) << std::endl;
			Eigen::MatrixXd b = Eigen::MatrixXd::Zero(3 * N, 1);
			Eigen::MatrixXd line_x = Eigen::MatrixXd::Zero(3 * N, 1);
			for (int i = 0;i < N;i++) {
				line_x(3 * i, 0) = pos_(i, 0) - old_pos_(i, 0) - h * vel_(i, 0);
				line_x(3 * i + 1, 0) = pos_(i, 1) - old_pos_(i, 1) - h * vel_(i, 1);
				line_x(3 * i + 2, 0) = pos_(i, 2) - old_pos_(i, 2) - h * vel_(i, 2);
			}
			std::cout << "line_x(1)" << std::endl;
			std::cout << line_x(3, 0) << std::endl;
			std::cout << line_x(4, 0) << std::endl;
			std::cout << line_x(5, 0) << std::endl;
			b =0.001*(-M * line_x / (h * h) + F);
			//deta_x = A.ldlt().solve(b);
			if (b.norm() < 1e-6) {
				std::cout << "b.norm" << std::endl;
				std::cout << b.norm() << std::endl;
				flag = true;
			}
			std::cout << "b(1)" << std::endl;
			std::cout << b(3, 0) << std::endl;
			std::cout << b(4, 0) << std::endl;
			std::cout << b(5,0) << std::endl;
			for (int i = 0;i < N;i++) {
				if (w_(i, i) < 1e6) {
					pos_(i, 0) += b(3 * i, 0);
					pos_(i, 1) += b(3 * i + 1, 0);
					pos_(i, 2) += b(3 * i + 2, 0);
					/*std::cout << "V" << std::endl;
					std::cout << V << std::endl;*/
				}
			}

		}

		//dense matrix
		//void LMSolve(double dt) {
		//	int N = num_vertices;
		//	int NC = num_edges;
		//	Eigen::MatrixXd H = Eigen::MatrixXd::Zero(3 * N, 3 * N);
		//	Eigen::MatrixXd F = Eigen::MatrixXd::Zero(3 * N, 1);
		//	Eigen::MatrixXd J = Eigen::MatrixXd::Zero(NC, 3 * N);
		//	double Energy = 0;
		//	for (int i = 0;i < NC;i++) {
		//		int id0 = edges_(i, 0);
		//		int id1 = edges_(i, 1);
		//		Eigen::Vector3d const p0 = pos_.row(id0);
		//		Eigen::Vector3d const p1 = pos_.row(id1);
		//		//C(i) = (p0 - p1).norm() - L(i);
		//		Eigen::Vector3d x = p0 - p1;
		//		double n_L = (p0 - p1).norm();
		//		Eigen::Vector3d f = -k * (n_L - rest_length_(i)) * (x / n_L);
		//		Energy += 0.5 * k * (n_L - rest_length_(i)) * (n_L - rest_length_(i));
		//		F.block<3, 1>(3 * id0, 0) += f;
		//		F.block<3, 1>(3 * id1, 0) -= f;
		//		Eigen::MatrixXd He = Eigen::MatrixXd::Zero(3, 3);
		//		Eigen::Vector3d n = (p0 - p1) / (p0 - p1).norm();
		//		J.block<1, 3>(i, 3 * id0) = n;
		//		J.block<1, 3>(i, 3 * id1) = -n;
		//	}
		//	H = k*J.transpose() * J;
		//	/*std::cout << "H"<< std::endl;
		//	std::cout << H << std::endl;*/
		//	Eigen::MatrixXd A = M / (dt * dt) + H;
		//	Eigen::MatrixXd diagH = Eigen::MatrixXd::Zero(3 * N, 3 * N);
		//	for (int i = 0;i < 3 * N;i++) {
		//		diagH(i, i) = A(i, i);
		//	}
		//	//a = 0;
		//	A += a * diagH;
		//	A /= a;
		//	//A = diagH;
		//	//Eigen::MatrixXd A_ = Eigen::MatrixXd::Zero(3 * (N - num_att), 3 * (N - num_att));
		//	//delete attachment
		//	for (int i = 0;i < num_att;i++) {
		//		RemoveRow(A, 3 * attachmentIds[i] - 3 * i);
		//		RemoveRow(A, 3 * attachmentIds[i] - 3 * i);
		//		RemoveRow(A, 3 * attachmentIds[i] - 3 * i);
		//	}
		//	for (int i = 0;i < num_att;i++) {
		//		RemoveColumn(A, 3 * attachmentIds[i] - 3 * i);
		//		RemoveColumn(A, 3 * attachmentIds[i] - 3 * i);
		//		RemoveColumn(A, 3 * attachmentIds[i] - 3 * i);
		//	}
		//	std::vector<T> tripletList_A;
		//	for (int i = 0;i < 3 * (N - num_att);i++) {
		//		for (int j = 0;j < 3 * (N - num_att);j++) {
		//			if (A(i, j) != 0) {
		//				tripletList_A.push_back(T(i, j, A(i, j)));
		//			}
		//		}
		//	}
		//	SparseMatrixType mat(3 * (N - num_att), 3 * (N - num_att));
		//	mat.setFromTriplets(tripletList_A.begin(), tripletList_A.end());
		//	cholesky_decomposition_.compute(mat);
		//	//get b
		//	Eigen::MatrixXd b = Eigen::MatrixXd::Zero(3 * N, 1);
		//	Eigen::MatrixXd line_x = Eigen::MatrixXd::Zero(3 * N, 1);
		//	for (int i = 0;i < N;i++) {
		//		line_x(3 * i, 0) = pos_(i, 0) - old_pos_(i, 0) - dt * vel_(i, 0);
		//		line_x(3 * i + 1, 0) = pos_(i, 1) - old_pos_(i, 1) - dt * vel_(i, 1);
		//		line_x(3 * i + 2, 0) = pos_(i, 2) - old_pos_(i, 2) - dt * vel_(i, 2);
		//	}
		//	b = -M * line_x / (dt * dt) + F;
		//	for (int i = 0;i < num_att;i++) {
		//		RemoveRow(b, 3 * attachmentIds[i] - 3 * i);
		//		RemoveRow(b, 3 * attachmentIds[i] - 3 * i);
		//		RemoveRow(b, 3 * attachmentIds[i] - 3 * i);
		//	}
		//	/*std::cout << "b" << std::endl;
		//	std::cout << b << std::endl;*/
		//	Eigen::MatrixXd deta_x(3 * (N - num_att), 1);
		//	deta_x = cholesky_decomposition_.solve(b.col(0));
		//	//deta_x = A.ldlt().solve(b);
		//	/*std::cout << "deta_x(1)" << std::endl;
		//	std::cout << deta_x(3, 0) << std::endl;
		//	std::cout << deta_x(4, 0) << std::endl;
		//	std::cout << deta_x(5, 0) << std::endl;*/
		//	cnt++;
		//	/*std::cout << "deta_x" << std::endl;
		//	std::cout << deta_x << std::endl;*/
		//	if (deta_x.norm() < 1e-5) {
		//		flag = true;
		//	}
		//	int cnt_ = 0;
		//	Eigen::MatrixXd temp_pos_ = Eigen::MatrixXd::Zero(N, 3);
		//	temp_pos_ = pos_;
		//	for (int i = 0;i < N;i++) {
		//		if (std::find(attachmentIds, attachmentIds + num_att, i) == attachmentIds + num_att) {
		//			//not attachment update position
		//			pos_(i, 0) += deta_x(3 * (i - cnt_), 0);
		//			pos_(i, 1) += deta_x(3 * (i - cnt_) + 1, 0);
		//			pos_(i, 2) += deta_x(3 * (i - cnt_) + 2, 0);
		//		}
		//		else {
		//			cnt_++;
		//		}
		//	}
		//	Eigen::MatrixXd temp = line_x.transpose() * M * line_x / (dt * dt);
		//	double nF = temp(0, 0) + Energy;
		//	/*std::cout << "nF" << std::endl;
		//	std::cout << nF << std::endl;
		//	std::cout << "lastF" << std::endl;
		//	std::cout << lastF << std::endl;*/
		//	if (nF > lastF) {
		//		a *= 10;
		//		pos_ = temp_pos_;
		//	}
		//	else {
		//		a /= 10;
		//		lastF = nF;
		//		
		//	}
		//}


		void LMSolve(double dt) {
			int N = num_vertices;
			int NC = num_edges;
			std::vector<T> tripletList_F;
			//Eigen::MatrixXd F = Eigen::MatrixXd::Zero(3 * N, 1);
			//Eigen::MatrixXd J = Eigen::MatrixXd::Zero(NC, 3 * N);
			double Energy = 0;
			std::vector<T> tripletList_M;
			for (int i = 0;i < N;i++) {
				if (map(i) != -1) {
					tripletList_M.push_back(T(3 * map(i), 3 * map(i), M_dt(3 * i, 3 * i)));
					tripletList_M.push_back(T(3 * map(i) + 1, 3 * map(i) + 1, M_dt(3 * i, 3 * i)));
					tripletList_M.push_back(T(3 * map(i) + 2, 3 * map(i) + 2, M_dt(3 * i, 3 * i)));
				}
			}
			SparseMatrixType M_(3 * (N - num_att), 3 * (N - num_att));
			M_.setFromTriplets(tripletList_M.begin(), tripletList_M.end());
			std::vector<T> tripletList_J;
			auto start = std::chrono::high_resolution_clock::now();
			for (int i = 0;i < NC;i++) {
				int id0 = edges_(i, 0);
				int id1 = edges_(i, 1);
				Eigen::Vector3d const p0 = pos_.row(id0);
				Eigen::Vector3d const p1 = pos_.row(id1);
				//C(i) = (p0 - p1).norm() - L(i);
				Eigen::Vector3d x = p0 - p1;
				double n_L = (p0 - p1).norm();
				Eigen::Vector3d f = -k * (n_L - rest_length_(i)) * (x / n_L);
				Energy += 0.5 * k * (n_L - rest_length_(i)) * (n_L - rest_length_(i));
				for (int j = 0;j < 3;j++) {
					if (map(id0) != -1) {
						tripletList_F.push_back(T(3 * map(id0) + j, 0, f(j)));
					}
					if (map(id1) != -1) {
						tripletList_F.push_back(T(3 * map(id1) + j, 0, -f(j)));

					}
				}
				/*F.block<3, 1>(3 * id0, 0) += f;
				F.block<3, 1>(3 * id1, 0) -= f;*/
				Eigen::Vector3d n = (p0 - p1) / (p0 - p1).norm();
				for (int j = 0;j < 3;j++) {
					if (map(id0) != -1) {
						tripletList_J.push_back(T(i, 3 * map(id0) + j, n(j)));
					}
					if (map(id1) != -1) {
						tripletList_J.push_back(T(i, 3 * map(id1) + j, -n(j)));
					}
				}
				/*J.block<1, 3>(i, 3 * id0) = n;
				J.block<1, 3>(i, 3 * id1) = -n;*/
			}
			auto end = std::chrono::high_resolution_clock::now();
			std::chrono::duration<double> diff = end - start;
			//std::cout << "get J SpendTime = " << diff.count() << "ms" << std::endl;
			SparseMatrixType J(NC, 3 * (N - num_att));
			
			J.setFromTriplets(tripletList_J.begin(), tripletList_J.end());
			SparseMatrixType F(3 * (N-num_att), 1);
			F.setFromTriplets(tripletList_F.begin(), tripletList_F.end());
			SparseMatrixType H(3 * (N - num_att),3 * (N - num_att));
			start = std::chrono::high_resolution_clock::now();
			H = k * J.transpose() * J;
			end = std::chrono::high_resolution_clock::now();
			diff = end - start;
			//std::cout << "get JTJ SpendTime = " << diff.count() << "ms" << std::endl;

			/*std::cout << "H"<< std::endl;
			std::cout << H << std::endl;*/
			SparseMatrixType A = M_ + H;
			SparseMatrixType diagA(3 * (N - num_att), 3 * (N - num_att));

			//Eigen::MatrixXd diagH = Eigen::MatrixXd::Zero(3 * N, 3 * N);
			start = std::chrono::high_resolution_clock::now();
			for (int i = 0;i < 3 * (N-num_att);i++) {
				diagA.insert(i, i) = A.coeff(i, i);
			}
			end = std::chrono::high_resolution_clock::now();
			diff = end - start;
			//std::cout << "get diagA SpendTime = " << diff.count() << "ms" << std::endl;

			//a = 0;
			start = std::chrono::high_resolution_clock::now();
			A += a * diagA;
			A /= a;
			end = std::chrono::high_resolution_clock::now();
			diff = end - start;
			//std::cout << "get A SpendTime = " << diff.count() << "ms" << std::endl;
			//A = diagH;
			//Eigen::MatrixXd A_ = Eigen::MatrixXd::Zero(3 * (N - num_att), 3 * (N - num_att));
			//delete attachment
			start = std::chrono::high_resolution_clock::now();
			cholesky_decomposition_.compute(A);
			end = std::chrono::high_resolution_clock::now();
			diff = end - start;
			//std::cout << "cholesky_decomposition_ SpendTime = " << diff.count() << "ms" << std::endl;
			//get b
			//SparseMatrixType b(3 * (N - num_att), 1);
			std::vector<T> tripletList_linex;
			start = std::chrono::high_resolution_clock::now();
			Eigen::MatrixXd b = Eigen::MatrixXd::Zero(3 * (N - num_att), 1);
			double temp = 0;
			for (int i = 0;i < N;i++) {
				double mass = M_dt(3 * i, 3 * i);
				if (map(i) != -1) {
					for (int j = 0;j < 3;j++) {
						tripletList_linex.push_back(T(3 * map(i) + j, 0,mass*(pos_(i, j) - old_pos_(i, j) - dt * vel_(i, j))));
					}
					temp += mass * (pos_(i, 0) - old_pos_(i, 0) - dt * vel_(i, 0)) * (pos_(i, 0) - old_pos_(i, 0) - dt * vel_(i, 0));
					/*line_x(3 * i, 0) = mass * (pos_(i, 0) - old_pos_(i, 0) - dt * vel_(i, 0));
					line_x(3 * i + 1, 0) = mass * (pos_(i, 1) - old_pos_(i, 1) - dt * vel_(i, 1));
					line_x(3 * i + 2, 0) = mass * (pos_(i, 2) - old_pos_(i, 2) - dt * vel_(i, 2));*/
				}
				
				
			}
			SparseMatrixType line_x(3 * (N-num_att), 1);
			b = line_x + F;
			end = std::chrono::high_resolution_clock::now();
			diff = end - start;
			//std::cout << "getb SpendTime = " << diff.count() << "ms" << std::endl;
			Eigen::MatrixXd deta_x(3 * (N - num_att), 1);
			start = std::chrono::high_resolution_clock::now();
			deta_x = cholesky_decomposition_.solve(b.col(0));
			end = std::chrono::high_resolution_clock::now();
			diff = end - start;
			//std::cout << "solveAx=b SpendTime =  " << diff.count() << "ms" << std::endl;
			//deta_x = A.ldlt().solve(b);
			/*std::cout << "deta_x(1)" << std::endl;
			std::cout << deta_x(3, 0) << std::endl;
			std::cout << deta_x(4, 0) << std::endl;
			std::cout << deta_x(5, 0) << std::endl;*/
			cnt++;
			/*std::cout << "deta_x" << std::endl;
			std::cout << deta_x << std::endl;*/
			if (deta_x.norm() < 1e-5) {
				flag = true;
			}
			int cnt_ = 0;
			Eigen::MatrixXd temp_pos_ = Eigen::MatrixXd::Zero(N, 3);
			temp_pos_ = pos_;
			start = std::chrono::high_resolution_clock::now();
			for (int i = 0;i < N;i++) {
				if (map(i)!=-1) {
					//not attachment update position
					pos_(i, 0) += deta_x(3 * (i - cnt_), 0);
					pos_(i, 1) += deta_x(3 * (i - cnt_) + 1, 0);
					pos_(i, 2) += deta_x(3 * (i - cnt_) + 2, 0);
				}
				else {
					cnt_++;
				}
			}
			end = std::chrono::high_resolution_clock::now();
			diff = end - start;
			//std::cout << "updatePos SpendTime =  " << diff.count() << "ms" << std::endl;
			//Eigen::MatrixXd temp = line_x.transpose() * M * line_x / (dt * dt);
			double nF = temp + Energy;
			/*std::cout << "nF" << std::endl;
			std::cout << nF << std::endl;
			std::cout << "lastF" << std::endl;
			std::cout << lastF << std::endl;*/
			if (nF > lastF) {
				a *= 10;
				pos_ = temp_pos_;
			}
			else {
				a /= 10;
				lastF = nF;

			}
		}

		void update(double dt, int maxIte) {
			//XPBD

			//PBD
			PBD_presolve(dt);
			flag = false;
			for (int i = 0;i < maxIte;i++) {
				//PBD_solve();
				//XPBDSolve(dt);
				NewtonSolve(dt);
				//LMSolve(dt);
				//GradientDescentSolve(dt);
				if (flag) {
					break;
				}
			}
			/*std::cout << "end" << std::endl;
			std::cout << cnt << std::endl;*/
			PBD_postsolve(dt);
			std::fstream f;
			std::string filename = "./Newton_data_21/cloth_" +std::to_string(frame)+".obj";
			f.open(filename, std::ios::out | std::ios::app);
			for (int i = 0;i < num_vertices;i++) {
				f << "v ";
				f<< pos_.row(i) << std::endl;
			}
			for (int i = 0;i < num_tris;i++) {
				f << "f ";
				int id0 = faces_(i, 0)+1;
				int id1 = faces_(i, 1)+1;
				int id2 = faces_(i, 2)+1;
				f << id0 <<" ";
				f << id1 <<" ";
				f << id2 << std::endl;
			}
			f.close();

		}

		void startGrab(Eigen::Vector3d mouse_pos,int faceId) {
			//get grabId
			int id0 = faces_(faceId, 0);
			int id1 = faces_(faceId, 1);
			int id2 = faces_(faceId, 2);
			int minId = id0;
			Eigen::Vector3d id0_pos = pos_.row(id0);
			Eigen::Vector3d id1_pos = pos_.row(id1);
			Eigen::Vector3d id2_pos = pos_.row(id2);
			double minDis = (id0_pos- mouse_pos).norm();
			if ((id1_pos - mouse_pos).norm() < minDis) {
				minDis = (id1_pos - mouse_pos).norm();
				minId = id1;
			}
			if ((id2_pos - mouse_pos).norm() < minDis) {
				minDis = (id2_pos - mouse_pos).norm();
				minId = id2;
			}
			grabId = minId;
			grab_inv_mas = inv_w_(grabId, grabId);
			inv_w_(grabId, grabId) = 0;
			
		}

		void moveGrabbed(Eigen::Vector3d pos) {
			if (grabId >= 0) {
				pos_(grabId,0) = pos.x();
				pos_(grabId,1) = pos.y();
				pos_(grabId,2) = pos.z();
			}
		}

		void endGrab(Eigen::Vector3d vel) {
			if (grabId >= 0) {
				inv_w_(grabId, grabId) = grab_inv_mas;
				vel_(grabId, 0) = vel.x();
				vel_(grabId, 1) = vel.y();
				vel_(grabId, 2) = vel.z();


			}
		}
};

Cloth cloth(dt);

Eigen::Vector3d getMousePos(igl::opengl::glfw::Viewer& viewer) {
	Eigen::Vector3d mouse_pos;
	float x = viewer.current_mouse_x;
	float y = viewer.core().viewport(3) - viewer.current_mouse_y;
	float z = viewer.down_mouse_z;
	Eigen::Matrix<float, 3, 1> mouse_screen_pos;
	mouse_screen_pos(0, 0) = x;
	mouse_screen_pos(1, 0) = y;
	mouse_screen_pos(2, 0) = z;
	Eigen::Matrix<float, 3, 1> mouse_world_pos;

	mouse_world_pos = mouse_world_pos = igl::unproject(mouse_screen_pos, viewer.core().view, viewer.core().proj, viewer.core().viewport);
	mouse_pos(0) = mouse_world_pos(0, 0);
	mouse_pos(1) = mouse_world_pos(1, 0);
	mouse_pos(2) = mouse_world_pos(2, 0);

	return mouse_pos;
}

bool mouse_down(igl::opengl::glfw::Viewer& viewer, int button, int modifier) {
	int fid;
	Eigen::Vector3f bc;
	std::cout << "mouse_down" << std::endl;
	// Cast a ray in the view direction starting from the mouse position
	float x = viewer.current_mouse_x;
	float y = viewer.core().viewport(3) - viewer.current_mouse_y;
	//gluUnProject((GLdouble)x, (GLdouble)y, (GLdouble)z, modelview, projection, viewport, &prePos(0), &prePos(1), &prePos(2));
	if (igl::unproject_onto_mesh(Eigen::Vector2f(x, y), viewer.core().view,
		viewer.core().proj, viewer.core().viewport, cloth.pos_, cloth.faces_, fid, bc))
	{	
		gMouseDown = true;
		// paint hit red
		//fid -> picked faces
		//prePos = bc;
		prePos = getMousePos(viewer);
		std::cout << "mouse_pos:";
		std::cout << prePos << std::endl;
		cloth.startGrab(prePos, fid);
		vel = Eigen::Vector3d::Zero();
		timer.start();

		return true;
	}
	return false;
}


bool mouse_up(igl::opengl::glfw::Viewer& viewer, int button, int modifier) {
	
	if (timer.getElapsedTime() > 0) {
			vel = (getMousePos(viewer) - prePos) / timer.getElapsedTime();
	}
	else {
			vel = Eigen::Vector3d::Zero();
	}
	cloth.endGrab(vel);
	timer.stop();
	gMouseDown = false;
	std::cout << "mouse_up" << std::endl;

	return false;
}




bool mouse_move(igl::opengl::glfw::Viewer& viewer, int mouse_x, int mouse_y)
{
	if (gMouseDown) {
		std::cout << "mouse_move" << std::endl;
		/*timer.stop();
		timer.start();*/

		cloth.moveGrabbed(getMousePos(viewer));


	}

	return false;
}



//Grabber grabber;



bool pre_draw(igl::opengl::glfw::Viewer& viewer)
{
	if (!pause)
	{
		frame++;
		// update_sphere(Vec3d(0.0, height, 0.0));

		// for (int i = 0; i < pull_points.size(); i++)
		// softbody.pos_.row(pull_points[i]) += Vec3d(0.0, height, 0.0);

		cloth.update(dt,maxIte);
		//std::cout << cloth.pos_.row(0) << std::endl;
		//std::cout << cloth.pos_.row(8) << std::endl;
	}
	// softbody.write_obj("../model/liver2/f" +std::to_string(frame++) + ".obj");

	viewer.data().clear();
	//std::cout << cloth.pos_ << std::endl;
	viewer.data().set_mesh(cloth.pos_, cloth.faces_);
	//viewer.core().align_camera_center(cloth.pos_, cloth.faces_);
	/*viewer.append_mesh();
	viewer.data().set_mesh(V, F);*/
	// viewer.data_list[0].set_colors(Eigen::RowVector3d(1, 0, 0));
	// viewer.data_list[1].set_colors(Eigen::RowVector3d(0, 1, 0));
	return false;
}


bool post_draw(igl::opengl::glfw::Viewer& viewer)
{
	for (auto& data : viewer.data_list)
	{
		data.clear();
	}
	return false;
}

bool key_pressed(igl::opengl::glfw::Viewer& viewer, unsigned int key, int modifiers)
{
	if (key == 'p')
	{
		pause = !pause;
		//std::cout << std::boolalpha << pause << std::endl;
	}

	return false;
}







int main()
{	
	cloth.init_constraints();
	//cloth.init_pd(dt);
	//std::cout << cloth.pos_ << std::endl;
    igl::opengl::glfw::Viewer viewer;
	/*cloth.update(dt,maxIte);
	std::cout << cloth.pos_.row(0) << std::endl;
	std::cout << cloth.pos_.row(8) << std::endl;
    viewer.data().set_mesh(cloth.pos_, cloth.faces_);
    viewer.data().set_face_based(true);
    viewer.launch();*/
	viewer.callback_pre_draw = &pre_draw;
	viewer.callback_post_draw = &post_draw;
	viewer.callback_key_pressed = &key_pressed;
	viewer.callback_mouse_down = &mouse_down;
	viewer.callback_mouse_move = &mouse_move;
	viewer.callback_mouse_up = &mouse_up;
	viewer.core().is_animating = true;
	viewer.data().set_face_based(false);
	viewer.launch();

	return 0;
}